unit frmStSCreatePackage;

interface

uses
  Windows, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, frmStSInputBase, ProgressDialog, DB, MemDS, DBAccess, MyAccess,
  ERPdbComponents, ImgList, AdvMenus, DataState, AppEvnts, SelectionDialog,
  Menus, ExtCtrls, Shader, DNMSpeedButton, DNMPanel, StdCtrls,
  ComCtrls, frmSTSImmaturePckgSrc, frmSTSHarvestPckgSrc, DAScript, MyScript, DBCtrls,
  BusObjBase, BusObjSeedToSale, wwdblook;

type
  TPackageLineItem = record
    TagID:        Integer;
    StsTag:       string;
    ActiveCount:  Integer;
    PackageID:    Integer;
  end;

  TPackageLineItems = array of TPackageLineItem;

  TStSCreatePackageMode = (modeUnknown, modeImmature, modeVegetative, modeHarvest, modeAnotherPackage);

  TfmStSCreatePackage = class(TfmStSInputBase)
    cbbPackgSrc: TComboBox;
    lblPackgSrc: TLabel;
    lblPackgTag: TLabel;
    lblPackgDate: TLabel;
    lblPackgName: TLabel;
    pnlPckgSrc: TPanel;
    qryHarvestNames: TERPQuery;
    dtpPackgDate: TDateTimePicker;
    edtPackgName: TEdit;
    qryPackgTag: TERPQuery;
    scrptMain: TERPScript;
    cbbNewPackg: TComboBox;
    qryUnits: TERPQuery;
    qryAvailable: TERPQuery;
    qryStrain: TERPQuery;
    qryAvailableTagID: TIntegerField;
    qryAvailableTag: TWideStringField;
    qryAvailableActiveCount: TLargeintField;
    qryAvailableCheck: TBooleanField;
    qryAvailableStrainName: TWideStringField;
    qryAvailableID: TIntegerField;
    qryAvPackage: TERPQuery;
    qryAvPackageID: TIntegerField;
    qryAvPackageCheck: TBooleanField;
    qryAvPackageTag: TWideStringField;
    qryAvPackagePkgID: TIntegerField;
    qryAvPackagePackageName: TWideStringField;
    qryAvPackageTagID: TIntegerField;
    edtStsTag: TEdit;
    qryPkgLines: TERPQuery;
    lbDepartment: TLabel;
    dblkcbbDepartment: TDBLookupComboBox;
    qryDepartment: TERPQuery;
    qryDepartmentClassID: TIntegerField;
    qryDepartmentClassName: TWideStringField;
    dsDepartment: TDataSource;
    Label1: TLabel;
    qryAvailableQty: TIntegerField;
    procedure btnCompletedClick(Sender: TObject);
    procedure btnCloseClick(Sender: TObject);
    procedure cbbPackgSrcChange(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure edtPackgNameEnter(Sender: TObject);
    procedure dblkcbbDepartmentCloseUp(Sender: TObject);
    procedure qryAvailableQtyChange(Sender: TField);
  private
    ///<summary> Defines form's view for the specified kind of Package </summary>
    FMode: TStSCreatePackageMode;
    ///<summary> ID of existing Package </summary>
    FPackageID: Integer;
    FStsTag: string;
    FStrainName: string;
    FBusobj: TStSPackage;
    FImmatureFrame: TfmImmaturePckgSrc;
    FPackageFrame:  TfmImmaturePckgSrc;
    FHarvestFrame:  TfmHarvestPckgSrc;
    ///<summary> A Max value that the user cannot exceed when specifying a quantity for a Package  </summary>
    FMaxQty: Double;
    ///<summary> The name of a temporary table to build query of available Package tags </summary>
    ///<remarks> Name generated by CommonDbLib.CreateUserTemporaryTable.  Table contains, among other things, serial numbers </remarks>
    FAvPkgTagTable: string;
  private
    ///<summary> cbbHarvestNames.OnChange handler  </summary>
    procedure OnHarvestChange(Sender: TObject);
    ///<summary> edtHarvestQty.OnExit handler  </summary>
    procedure OnHarvestQtyExit(Sender: TObject);
    ///<summary> edtHarvestQty.OnChange handler  </summary>
    procedure OnHarvestQtyChange(Sender: TObject);
    ///<summary> cbbStrain.OnChange handler  </summary>
    procedure OnChangeStrain(Sender: TObject);
  private
    ///<summary> Builds SQL for qryPackgTag </summary>
    procedure AddSQL_qryPackgTag;
    ///<summary> Builds SQL and populates qryAvailable with available tags depend on Package type  </summary>
    procedure BuildAvailableTagQry(aPkgType: TStsPackageType);
    ///<summary> Builds SQL and populates qryPkgLines with PackageLines for specific PakageID  </summary>
    procedure BuildPackageLinesQry(const aPkgID: Integer);
    ///<summary> Builds SQL and populates qryAvPackage with available Package Tags  </summary>
    procedure BuildAvPackageTagQry;
    ///<summary> Creates and places Plant frame depend on Package type </summary>
    procedure CreatePlantFrame(aPkgType: TStsPackageType);
    ///<summary> Creates and places Package frame  </summary>
    procedure CreatePackageFrame;
    ///<summary> Creates and places Harvest frame </summary>
    procedure CreateHarvestFrame;
    ///<summary> Populates temporary table FAvPkgTagTable with data. qryPackgTag takes data from this table.  </summary>
    procedure Populate_qryPackgTag;
    ///<summary> Shows a progress bar while the query is running </summary>
    procedure ExecutewithProgress(AllowCancel:Boolean=False);
    ///<summary> Changes 'Enabled', 'Readonly' property of controls depending on Mode value  </summary>
    procedure UpdateReadOnly;
    ///<summary> Updates visibilty and captions of detail grid depending on Mode value </summary>
    procedure UpdateDetailGridView;
    ///<summary> Changes captions of controls depending on Mode value  </summary>
    procedure UpdateView;
  private
    ///<summary> Adds additional SQL statements when preparing SQL text for building temporary table  </summary>
    function ExtraSQL(const aTableName: string): string;
    ///<returns> qryDepartment.ClassId </returns>
    function GetQryDeptID: Integer;
    ///<returns> Package type depending on selected item of "Package source" combobox </returns>
    function GetPackageType: TStsPackageType;
    ///<returns> The TLineItem array. Contains information for each tag the user chooses to put in a Package. Used in case of pkgImmature, pkgVegetative, pkgPackage  </returns>
    function GetLineItems: TPackageLineItems;
    ///<returns> True if form displays data of existing package  </returns>
    function IsReadOnly: Boolean;
  private
    function GetHarvestID: Integer;
    function GetUOMID: Integer;
    function GetUOM: string;
    function GetPackedQty: Double;
    function GetPackageUOMMultiplier: Double;
  public
    constructor Create(AOwner: TComponent); overload; override;
    constructor Create(Aowner: TComponent; aStsTagObj: TStsTags); overload;
    constructor Create(AOwner: TComponent; AMode: TStSCreatePackageMode; const APackageID: Integer); overload;
    constructor Create(Aowner: TComponent; aMyDAcDataconnection: TMyDAcDataconnection; aBusobj: TBusobj); overload; override;

    ///<summary> Points to TStSPackage instance used to create this form </summary>
    function StsPackage: TStSPackage;

    property HarvestID: Integer           read GetHarvestID;
    property UOMID: Integer               read GetUOMID;
    property UOM: string                  read GetUOM;
    property PackedQty: Double            read GetPackedQty;
    property PackageUOMMultiplier: Double read GetPackageUOMMultiplier;
    property PackageType: TStsPackageType read GetPackageType;
    property LineItems: TPackageLineItems read GetLineItems;
  end;

implementation

{$R *.dfm}

uses
  Math, CommonLib, CommonDbLib, StsLib, tcConst, StringUtils, LogLib, StsUtils, Wwdbigrd, Wwdbgrid;

procedure TfmStSCreatePackage.btnCloseClick(Sender: TObject);
begin
  inherited;
  ModalResult := mrCancel;
end;

procedure TfmStSCreatePackage.btnCompletedClick(Sender: TObject);
begin
  inherited;

  // check if the user has selected at least one tag to place in the package when creating a package from Immature, Vegetative or Another package tags.
  case PackageType of
    pkgImmature, pkgVegetative, pkgPackage:
      begin
         if Length(GetLineItems) = 0 then begin
           MessageDlgXP_Vista('To create a package, you need to select at least one tag', mtWarning, [mbOK], 0);
           Exit;
         end;
      end;
  end;

  // check if all fields of the Package are filled
  if not IsExistsEmptyControls(Self) then begin
    StsPackage.InitDeptID := GetQryDeptID;
    ModalResult := mrOk;
  end;
end;

procedure TfmStSCreatePackage.BuildAvPackageTagQry;
var
  iDept: Integer;
  sErrorMsg, sTableName: string;
begin
  try
    sErrorMsg  := '';
    sTableName := CommonDbLib.GetUserTemporaryTableName('StsPkg');
    Logtext('TfmStSCreatePackage.BuildAvPackageTagQry temp_table: ' + sTableName,'', True);

    // select not yet packed Packages belonging to DeptID department
    with qryAvPackage.SQL do begin
      Clear;
      Add( Format(
        'Select T.ID, T.PkgID, T.Check, ST.StsTag AS Tag, T.PackageName, ST.ID AS TagID FROM %s AS T ' +
        'INNER JOIN tblststags AS ST ON T.StsTagsID = ST.ID ' +
        'WHERE (ST.DeptID=:DeptID) AND (T.ParentPkgID = 0) AND (ST.TagProductID =:PkgProductID) ORDER BY ST.StsTag;', [sTableName]) );
    end;

    // Qry to edit 'Check' field in dbgrid
    with qryAvPackage.SQLUpdate do begin
      Clear;
      Add(Format('UPDATE %s AS T SET T.Check=:Check WHERE T.ID=:ID;', [sTableName]));
    end;

    // create temp table like tblstspackage and add a new "Check" field that is not in tblstspackage to use it to select records by checking the boxes
    CommonDbLib.ExecuteDBCommand(Format(
      'DROP TABLE if EXISTS %s; ' +
      'CREATE TABLE %s LIKE tblstspackage; ' +
      'ALTER TABLE %s ADD COLUMN `Check` TINYINT(1) NOT NULL DEFAULT 0;'+
      'ALTER TABLE %s ADD COLUMN `PkgID` INT(11) NOT NULL DEFAULT 0;',
      [sTableName, sTableName, sTableName, sTableName]), sErrorMsg);

    if Length(sErrorMsg) > 0 then
      Logtext(Format('TfmStSCreatePackage.BuildAvPackageTagQry error: %s', [sErrorMsg]),'', True);

    // Populate temp table
    scrptMain.SQL.text := Format(
      'INSERT INTO %s (PkgID, StsTagsID, ParentPkgID, PackageName, PackageDate, PackageType, HarvestID, UOMID, UOM, UOMMultiplier, PackedQty, Done, msTimeStamp, msUpdateSiteCode) ' +
      'SELECT * FROM tblstspackage ORDER BY ID;', [sTableName]);
    ExecutewithProgress;

    iDept := StsPackage.InitDeptID;
    if iDept = 0 then iDept := GetQryDeptID;

    // Show records for a specific Department
    CloseDB(qryAvPackage);
    qryAvPackage.ParamByName('DeptID').AsInteger       := iDept;
    qryAvPackage.ParamByName('PkgProductID').AsInteger := StsPackage.ProductID;
    OpenDB(qryAvPackage);

  except
    on E: Exception do
      Logtext(Format('TfmStSCreatePackage.BuildAvailableTagQry exception: [%s] %s', [E.Classname, E.Message]),'', True);
  end;
end;

procedure TfmStSCreatePackage.BuildPackageLinesQry(const aPkgID: Integer);
const
  cSelect = 'SELECT S.StsTag, PL.Qty FROM tblststags S INNER JOIN tblstspackagelines PL ON S.ID = PL.StsTagsID WHERE PackageID=%d ORDER BY StsTag; ';
begin
  CloseDB(qryPkgLines);
  qryPkgLines.SQL.Text := Format(cSelect, [aPkgID]);
  OpenDB(qryPkgLines);
end;

procedure TfmStSCreatePackage.BuildAvailableTagQry(aPkgType: TStsPackageType);
var
  sErrorMsg, sTableName, sExtraSQL, sPhase: string;
begin
  try
    sErrorMsg  := '';
    sTableName := CommonDbLib.GetUserTemporaryTableName('StsTags');
    Logtext('TfmStSCreatePackage.BuildAvailableTagQry temp_table: ' + sTableName,'', True);

    // Qry to populate dbgrid in Plant frame
    with qryAvailable.SQL do begin
      Clear;
      Add('Select ');
      Add('T.ID, ');
      Add('T.TagID, ');
      Add('T.Check, ');
      Add('T.Qty, ');
      Add('T.Serialnumber AS Tag, ');
      Add('(T.Plantcount - T.ChangedCount - T.WastedCount - T.Destroycount - T.TransferedCount - T.UsedCount) AS ActiveCount, ');
      Add('T.StrainName ');
      Add('FROM '+ sTableName + ' AS T ');
      Add('WHERE (T.StSPhase =:StsPhase) AND (T.Plantcount - T.ChangedCount - T.WastedCount - T.Destroycount - T.TransferedCount - T.UsedCount) > 0 ');
      Add('ORDER BY T.Serialnumber;');
    end;

    // Qry to edit 'Check' field in dbgrid in Plant frame
    with qryAvailable.SQLUpdate do begin
      Clear;
      Add(Format('UPDATE %s AS T SET T.Check=:Check, T.Qty=:Qty WHERE T.ID=:ID;', [sTableName]));
    end;

    // Qry to populate cbbStrain in Plant frame
    with qryStrain.SQL do begin
      Clear;
      Add( Format(
        'SELECT DISTINCT T.StrainName FROM %s AS T ' +
        'WHERE (T.StSPhase =:StsPhase) AND ' +
        '(T.Plantcount - T.ChangedCount - T.WastedCount - T.Destroycount - T.TransferedCount - T.UsedCount) > 0 ' +
        'ORDER BY T.StrainName;',
        [sTableName]) );
    end;

    CommonDbLib.ExecuteDBCommand(Format('DROP TABLE if EXISTS %s3; '  +
                                        'CREATE TABLE %s3 ( ' +
                                        'partsId int(11) DEFAULT  0, ' +
                                        'serialnumber varchar(100) DEFAULT NULL, ' +
                                        'pqaid int(11) DEFAULT NULL, ' +
                                        'supplierid int(11) DEFAULT  0 ' +
                                        ' ) ENGINE=MyISAM DEFAULT CHARSET=UTF8;', [sTableName, sTableName]), sErrorMsg);

    if Length(sErrorMsg) > 0 then
      Logtext(Format('TfmStSCreatePackage.BuildAvailableTagQry error: %s', [sErrorMsg]),'', True);

//    sExtraSQL := ExtraSQL(sTableName);
    // add a new "Check" field that is not in tblststags to use it to select records by checking the boxes
    sExtraSQL := sExtraSQL + Format('ALTER TABLE %s ADD COLUMN `Check` TINYINT(1) NOT NULL DEFAULT 0;', [sTableName]);
    // "Qty" field used in Immature mode to set required qty in grid
    sExtraSQL := sExtraSQL + Format('ALTER TABLE %s ADD COLUMN `Qty` INT(11) NULL DEFAULT NULL;', [sTableName]);
    sExtraSQL := sExtraSQL + ExtraSQL(sTableName);
    // fill Qty with ActiveCount values
    sExtraSQL := sExtraSQL + Format('UPDATE %s T SET T.Qty = T.Plantcount - T.ChangedCount - T.WastedCount - T.Destroycount - T.TransferedCount - T.UsedCount;', [sTableName]);

    with scrptMain do
    begin
      SQL.text := StSTagList(sTableName); // creates table sTableName and other supporting tables
      SQL.Add(sExtraSQL);
    end;
    ExecutewithProgress;

    sPhase := '';
    case APkgType of
      pkgImmature:   sPhase := 'I';
      pkgVegetative: sPhase := 'V';
    end;

    CloseDB(qryStrain);
    qryStrain.ParamByName('StsPhase').AsString := sPhase;
    OpenDB(qryStrain);

    // Show records for a specific strain, because plant tags must belong to the same strain in the same package
    if qryStrain.Active and (qryStrain.RecordCount > 0) and not qryStrain.FieldByName('StrainName').IsNull then
    begin
      CloseDB(qryAvailable);
      qryAvailable.ParamByName('StsPhase').AsString := sPhase;
      OpenDB(qryAvailable);
      qryAvailable.Filter   := 'StrainName=' + QuotedStr(qryStrain.FieldByName('StrainName').AsString);
      qryAvailable.Filtered := True;
    end;

  except
    on E: Exception do
      Logtext(Format('TfmStSCreatePackage.BuildAvailableTagQry exception: [%s] %s', [E.Classname, E.Message]),'', True);
  end;
end;

procedure TfmStSCreatePackage.cbbPackgSrcChange(Sender: TObject);
var
  I: Integer;
  LType, tmpPkgType: TStsPackageType;
  sSpecifier: string;
begin
  inherited;
  try
    Assert(Sender is TComboBox, 'Expecting Sender is TComboBox');
    Assert(StsPackage <> nil,   'Expecting StsPackage <> nil');

    pnlPckgSrc.Caption := 'You cannot create a package';

    // to clear frame area
    for I := 0 to Pred(pnlPckgSrc.ControlCount) do
      pnlPckgSrc.Controls[I].Parent := nil;

    tmpPkgType := pkgUnknown;

    if cbbPackgSrc.Items.Count > 0 then
      for LType := Low(PackageTypeNames) to High(PackageTypeNames) do
        if SameText(PackageTypeNames[LType], cbbPackgSrc.Items[cbbPackgSrc.ItemIndex]) then begin
          tmpPkgType := LType;
          Break;
        end;

    FMode := TStSCreatePackageMode(Ord(tmpPkgType));

    if not IsReadOnly then begin  // Package name depend on selected Package type
      case tmpPkgType of
        pkgUnknown:    sSpecifier := '';
        pkgImmature:   sSpecifier := 'Immature';
        pkgVegetative: sSpecifier := 'Vegetative';
        pkgHarvest:    sSpecifier := 'Harvest';
        pkgPackage:    sSpecifier := 'AnotherPkg';
      end;

      edtPackgName.Text := StsPackage.DefaultPackageName(sSpecifier);
    end;

    // place frame depend on selected Package type
    case tmpPkgType of
      pkgImmature:
        CreatePlantFrame(pkgImmature);

      pkgVegetative:
        CreatePlantFrame(pkgVegetative);

      pkgHarvest:
        CreateHarvestFrame;

      pkgPackage:
        CreatePackageFrame;
    end;

    UpdateDetailGridView;
  finally
    // Enable button "Save"
    btnCompleted.Enabled := not IsReadOnly and ((Sender as TComboBox).ItemIndex >= 0) and (pnlPckgSrc.ControlCount > 0);
  end;
end;

constructor TfmStSCreatePackage.Create(AOwner: TComponent);
begin
  inherited;
  FMode := modeUnknown;
end;

constructor TfmStSCreatePackage.Create(AOwner: TComponent;
  AMode: TStSCreatePackageMode; const APackageID: Integer);
begin
  inherited Create(AOwner);

  FMode      := AMode;
  FPackageID := APackageID;
end;

constructor TfmStSCreatePackage.Create(Aowner: TComponent;
  aMyDAcDataconnection: TMyDAcDataconnection; aBusobj: Tbusobj);
begin
  inherited;
  FMode      := modeImmature;
  FPackageID := 0;
end;

constructor TfmStSCreatePackage.Create(Aowner: TComponent;  aStsTagObj: TStsTags);
var
  createMode: TStSCreatePackageMode;
begin
  createMode := modeUnknown;

  if aStsTagObj.StsPhase = 'I' then
    createMode := modeImmature;

  if aStsTagObj.StsPhase = 'V' then
    createMode := modeVegetative;

  // use these values to create a prefilled Package window, e.g if you create window in 'Change Phase' window
  FStsTag     := aStsTagObj.StsTag;
  FStrainName := aStsTagObj.StSStrain.StrainName;

  Create(AOwner, createMode, 0);
end;

procedure TfmStSCreatePackage.CreateHarvestFrame;
var
  iDept: Integer;
begin

  FreeAndNil(FHarvestFrame);

  if FHarvestFrame = nil then begin
    FHarvestFrame := TfmHarvestPckgSrc.Create(Self);
    FHarvestFrame.OnHarvestChange    := OnHarvestChange;
    FHarvestFrame.OnHarvestQtyExit   := OnHarvestQtyExit;
    FHarvestFrame.OnHarvestQtyChange := OnHarvestQtyChange;
  end;

  // populate cbbHarvestName.Items
  if IsReadOnly then
    iDept := StsPackage.StSTagObj.DeptID
  else begin
    iDept := StsPackage.InitDeptID;
    if iDept = 0 then iDept := GetQryDeptID;
  end;

  Assert(iDept <> 0, 'Expected iDept <> 0');

  FHarvestFrame.lbInfo.Visible := not IsReadOnly;

  FHarvestFrame.cbbHarvestName.Items.Clear;
  CloseDB(qryHarvestNames);
  qryHarvestNames.ParamByName('DeptID').AsInteger := iDept;
  openDB(qryHarvestNames);

  if IsReadOnly and qryHarvestNames.Active then begin
    qryHarvestNames.Filter   := Format('ID=%d', [StsPackage.HarvestID]);
    qryHarvestNames.Filtered := True;
  end;

  if IsReadOnly then
    FHarvestFrame.edtHarvestQty.Text := FormatFloat('0.00', StsPackage.PackedQty);


  if qryHarvestNames.RecordCount = 0 then begin
    pnlPckgSrc.Caption := 'You cannot create a package. There is not a single Harvest.';
    Exit;
  end;

  with qryHarvestNames do begin
    if Active then
    begin
      First;
      while not Eof do begin
        if not FieldByName('HarvestName').IsNull then
          FHarvestFrame.cbbHarvestName.Items.Add(FieldByName('HarvestName').AsString);
        Next;
      end;
    end;
  end;

  // populate cbbPackgUnits.Items
  if IsReadOnly and qryUnits.Active then begin
    qryUnits.Filter   := Format('UnitID=%d', [StsPackage.UOMID]);
    qryUnits.Filtered := True;
  end;

  with FHarvestFrame.cbbPackgUnits do begin
    LookupField := 'UnitName';
    LookupTable := qryUnits;
    if qryUnits.Active and not qryUnits.FieldByName('UnitName').IsNull then
      FHarvestFrame.cbbPackgUnits.DisplayValue := qryUnits.FieldByName('UnitName').AsString;
  end;

  if FHarvestFrame.cbbHarvestName.Items.Count > 0 then
  begin
    FHarvestFrame.cbbHarvestName.ItemIndex := 0;
    OnHarvestChange(FHarvestFrame.cbbHarvestName);
  end;

  FHarvestFrame.Parent := pnlPckgSrc;
end;

procedure TfmStSCreatePackage.CreatePackageFrame;
begin
  FreeAndNil(FImmatureFrame); // FImmatureFrame is the same Class as FPackageFrame. You can't have both components at the same time.
  FreeAndNil(FPackageFrame);

  if FPackageFrame = nil then
    FPackageFrame := TfmImmaturePckgSrc.Create(Self, pkgPackage);

  if IsReadOnly then begin
    BuildPackageLinesQry(StsPackage.ID);
    Assert(qryPkgLines.Active, 'Expecting qryPkgLines is active');
    FPackageFrame.dsAvailable.DataSet := qryPkgLines;
  end else begin
    BuildAvPackageTagQry;
    if not qryAvPackage.Active then begin
      pnlPckgSrc.Caption := Format('You cannot create a package. There are no "%s" tags available.', [PackageTypeNames[pkgPackage]]);
      Exit;
    end;
    Assert(qryAvPackage.Active, 'Expecting qryAvPackage is active');
    FPackageFrame.dsAvailable.DataSet := qryAvPackage;
  end;


  FPackageFrame.Parent := pnlPckgSrc;
end;

procedure TfmStSCreatePackage.CreatePlantFrame(aPkgType: TStsPackageType);
const
  cInfo = 'List of available  tags.  Check the tags to be placed in the package.';
var
  cbbStrain: TComboBox;
  sInfo: string;
begin
  FreeAndNil(FPackageFrame); // FPackageFrame is the same Class as FImmatureFrame. You can't have both components at the same time.
  FreeAndNil(FImmatureFrame);

  if FImmatureFrame = nil then begin
    FImmatureFrame := TfmImmaturePckgSrc.Create(Self, aPkgType);
    if not IsReadOnly then
      FImmatureFrame.OnChangeStrain := OnChangeStrain;
  end;

  cbbStrain := FImmatureFrame.cbbStrain;
  cbbStrain.Visible := not IsReadOnly;
  FImmatureFrame.lblStrain.Visible := not IsReadOnly;

  if IsReadOnly then begin
    BuildPackageLinesQry(StsPackage.ID);
    Assert(qryPkgLines.Active, 'Expecting qryPkgLines is active');
    FImmatureFrame.dsAvailable.DataSet := qryPkgLines;
  end else begin

    BuildAvailableTagQry(aPkgType);
    if not qryAvailable.Active then begin
      pnlPckgSrc.Caption := Format('You cannot create a package. There are no "%s" tags available.', [PackageTypeNames[aPkgType]]);
      Exit;
    end;
    Assert(qryAvailable.Active, 'Expecting qryAvailable is active');
    FImmatureFrame.dsAvailable.DataSet := qryAvailable;

    // populate cbbStrain items
    cbbStrain.Items.Clear;
    if qryStrain.RecordCount > 0 then
      with qryStrain do begin
        First;
        while not EOF do begin
          if not Fields[0].IsNull then
            cbbStrain.Items.Add(Fields[0].AsString);
          Next;
        end;
      end;

    // if the TfmStSCreatePackage window was created for a specific TStsTags instance
    if (Length(FStrainName) > 0) and (cbbStrain.Items.Count > 0) and (cbbStrain.Items.IndexOf(FStrainName) <> -1) then begin
      cbbStrain.ItemIndex := cbbStrain.Items.IndexOf(FStrainName);
      OnChangeStrain(cbbStrain);
      // select checkbox in line with Tag = FStsTag
      if qryAvailable.Active and qryAvailable.Locate('Tag', fStsTag, [loCaseInsensitive]) then begin
        qryAvailable.Edit;
        qryAvailable.FieldByName('Check').AsBoolean := True;
        qryAvailable.Post;
      end;
    end;

    if Length(FStrainName) = 0 then
      if cbbStrain.Items.Count > 0 then
        cbbStrain.ItemIndex := 0;
  end;

  case aPkgType of
    pkgImmature:   sInfo := cInfo + '  Set the required Qty.';
    pkgVegetative: sInfo := cInfo;
  end;

  FImmatureFrame.pnlLTop.Caption := sInfo;
  FImmatureFrame.Parent := pnlPckgSrc;
end;

procedure TfmStSCreatePackage.dblkcbbDepartmentCloseUp(Sender: TObject);
begin
  inherited;
  cbbPackgSrcChange(cbbPackgSrc);
end;

procedure TfmStSCreatePackage.edtPackgNameEnter(Sender: TObject);
begin
  inherited;
  (Sender as TEdit).SelectAll;
end;

procedure TfmStSCreatePackage.ExecutewithProgress(AllowCancel: Boolean);
begin
  with scrptMain do begin
    Processingcursor(True);
    try
      ShowProgressbar(WAITMSG, strCount(';' , SQL.Text));

      try
        Execute;
      finally
        HideProgressbar;
      end;
    finally
      ProcessingCursor(False);
    end;
  end;
end;

function TfmStSCreatePackage.ExtraSQL(const aTableName: string): string;
begin
  Result := 'update '+aTableName + ' set Alloctype ="Used"     where Alloctype <> "In-Stock" and Alloctype <> "New";' +
            'update '+aTableName + ' set Alloctype ="Not-Used" where Alloctype =  "In-Stock" or  Alloctype  = "New";';
  Result := Result +
           'insert ignore into  ' + aTableName +'3 (partsId , serialnumber , pqaid) Select ' +
                       ' T.partsId, T.serialnumber, MIN(pqa.pqaid) pqaid ' +
                       ' from ' + aTableName +' T ' +
                       ' INNER JOIN tblpqa pqa ON pqa.productId = T.partsID ' +
                       ' INNER JOIN tblpqadetails pqad ON pqa.pqaid = pqad.pqaid AND pqad.value = T.serialnumber AND  pqad.PQAType ="SN" ' +
                       ' GROUP BY T.partsId, T.serialnumber; ' +
           ' UPDATE ' + aTableName +'3 t INNER JOIN tblpqa pqa ON t.pqaid = pqa.pqaid AND pqa.transtype = "TPurchaseOrderLine" INNER JOIN tblpurchaseorders po ON pqa.transid = po.PurchaseOrderID SET T.supplierId = po.ClientID;'+
           ' update ' + aTableName +' T1 inner join ' + aTableName +'3 T2 on T1.partsId = t2.partsId and t1.Serialnumber = t2.serialnumber Set T1.supplierId = T2.supplierid;'+
           ' update ' + aTableName +' T inner join tblclients  C on C.clientId = T.supplierid Set T.Supplier = C.company;';
end;

procedure TfmStSCreatePackage.FormCreate(Sender: TObject);
begin
  inherited;
  FormColor := $0091C8FF;
  if not IsReadOnly then
    AddSQL_qryPackgTag;
end;

procedure TfmStSCreatePackage.FormShow(Sender: TObject);
begin
  inherited;

  with TitleShader do begin
    FromColor       := clWhite;
    FromColorMirror := clWhite;
    ToColor         := clWhite;
    ToColorMirror   := clWhite;
  end;

  OpenDB(qryDepartment);
  with qryDepartment do begin
    if Active and (RecordCount > 0) then begin
      if IsReadOnly then
        dblkcbbDepartment.KeyValue := StSPackage.StSTagObj.DeptID
      else begin
        if StsPackage.InitDeptID <> 0 then begin
          Filter := Format('ClassID=%d', [StsPackage.InitDeptID]);
          Filtered := True;
        end;
        First;
        dblkcbbDepartment.KeyValue := FieldByName('ClassID').AsInteger;
      end;
    end;
  end;

  if not IsReadOnly then
    Populate_qryPackgTag;

  // qryUnits
  CloseDB(qryUnits);
  qryUnits.ParamByName('partId').AsInteger  := stslib.StSPackageTagProductID;
  openDB(qryUnits);

  // populate cbbNewPackg.Items
  if not IsReadOnly then begin
    cbbNewPackg.Items.Clear;
    with qryPackgTag do
      if Active then
      begin
        First;
        while not EOF do
        begin
          if not Fields[0].IsNull then
            cbbNewPackg.Items.Add(Fields[0].AsString);
          Next;
        end;
      end;

    if cbbNewPackg.Items.Count > 0 then
      cbbNewPackg.ItemIndex := 0;
  end;

  UpdateView;
  UpdateReadonly;
  UpdateDetailGridView;

end;

function TfmStSCreatePackage.GetHarvestID: Integer;
var
  sHarvestName: string;
begin
  Result := -1;
  if GetPackageType <> pkgHarvest then Exit;

  Assert(FHarvestFrame <> nil, '');
  sHarvestName := FHarvestFrame.cbbHarvestName.Text;

  if qryHarvestNames.Active then
    if qryHarvestNames.Locate('HarvestName', sHarvestName, [loCaseInsensitive]) then
      Result := qryHarvestNames.FieldByName('Id').AsInteger;
end;

function TfmStSCreatePackage.GetLineItems: TPackageLineItems;
var
  I: Integer;
  sSTrainName: string;
begin
  SetLength(Result, 0);

  try
    case PackageType of

      pkgImmature, pkgVegetative:
        with qryAvailable do begin
          if Active then begin
            if State in dsEditModes then Post;

            Assert(FImmatureFrame <> nil, 'Expecting FImmatureFrame <> nil');
            if FImmatureFrame <> nil then sSTrainName := FImmatureFrame.cbbStrain.Text;

            I := 0;
            SetLength(Result, 10); // init

            First;
            while not EOF do begin
              if not FieldByName('Check').IsNull then begin
                if I > High(Result) then SetLength( Result, Length(Result) + Length(Result) );

                // get data from selected item
                if FieldByName('Check').AsBoolean and SameText(FieldByName('StrainName').AsString, sSTrainName) then begin
                  Result[I].TagID        := FieldByName('TagID').AsInteger;
                  Result[I].StSTag       := FieldByName('Tag').AsString;
                  Result[I].PackageID    := 0;

                  if PackageType = pkgImmature then
                    Result[I].ActiveCount  := FieldByName('Qty').AsInteger
                  else
                    Result[I].ActiveCount  := FieldByName('ActiveCount').AsInteger;

                  Inc(I);
                end;
              end;
              Next;
            end;

            SetLength(Result, I);  // truncate Result to actual size
          end;
        end;

      pkgPackage:
        with qryAvPackage do begin
          if Active then begin
            if State in dsEditModes then Post;

            I := 0;
            SetLength(Result, 10); // init

            First;
            while not EOF do begin
              if not FieldByName('Check').IsNull then begin
                if I > High(Result) then SetLength( Result, Length(Result) + Length(Result) );

                // get data from selected item
                if FieldByName('Check').AsBoolean then begin
                  Result[I].TagID        := FieldByName('TagID').AsInteger;
                  Result[I].StSTag       := FieldByName('Tag').AsString;
                  Result[I].ActiveCount  := 1;
                  Result[I].PackageID    := FieldByName('PkgID').AsInteger;
                  Inc(I);
                end;
              end;
              Next;
            end;

            SetLength(Result, I);  // truncate Result to actual size
          end;
        end;

    end;
  except
    on E: Exception do
      Logtext(Format('TfmStSCreatePackage.GetLineItems exception: [%s] %s', [E.Classname, E.Message]),'', True);
  end;
end;

function TfmStSCreatePackage.GetPackageType: TStsPackageType;
var
  LType: TStsPackageType;
begin
  Result := pkgUnknown;
  if cbbPackgSrc.Items.Count > 0 then
    for LType := Low(PackageTypeNames) to High(PackageTypeNames) do
      if SameText(PackageTypeNames[LType], cbbPackgSrc.Items[cbbPackgSrc.ItemIndex]) then begin
        Result := LType;
        Exit;
      end;
end;

function TfmStSCreatePackage.GetPackageUOMMultiplier: Double;
begin
  Result := 0;

  if not qryUnits.FieldByName('Multiplier').IsNull then
    Result := qryUnits.FieldByName('Multiplier').AsFloat;
end;

function TfmStSCreatePackage.GetPackedQty: Double;
begin
  Result := 0;

  case GetPackageType of
    pkgHarvest: Result := StrToFloatDef(FHarvestFrame.edtPackgQty.Text, 0);
  end;
end;

function TfmStSCreatePackage.GetQryDeptID: Integer;
begin
  Result := 0;
  with qryDepartment do begin
    if Active and (RecordCount > 0) and not FieldByName('ClassID').IsNull then
      Result := FieldByName('ClassID').AsInteger;
  end;
end;

function TfmStSCreatePackage.GetUOM: string;
begin
  Result := '';

  if not qryUnits.FieldByName('UnitName').IsNull then
    Result := qryUnits.FieldByName('UnitName').AsString;
end;

function TfmStSCreatePackage.GetUOMID: Integer;
begin
  Result := -1;

  if not qryUnits.FieldByName('UnitID').IsNull then
    Result := qryUnits.FieldByName('UnitID').AsInteger;
end;

function TfmStSCreatePackage.IsReadOnly: Boolean;
begin
  Result := FPackageID <> 0;
end;

procedure TfmStSCreatePackage.OnHarvestChange(Sender: TObject);
var
  sHarvestName, sMaxPackgQty, sUOM: string;
  TotalQty, PackedQty: Double;
begin
  TotalQty  := 0;
  PackedQty := 0;
  sUOM      := '';

  Assert(FHarvestFrame <> nil, 'Expected frame FHarvestFrame <> nil');
  sHarvestName := FHarvestFrame.cbbHarvestName.Text;

  if qryHarvestNames.Active then
    if qryHarvestNames.Locate('HarvestName', sHarvestName, [loCaseInsensitive]) then
    begin
       if not qryHarvestNames.FieldByName('UOM').IsNull then
         sUOM := qryHarvestNames.FieldByName('UOM').AsString;

       if not qryHarvestNames.FieldByName('TotalQty').IsNull then
         TotalQty := qryHarvestNames.FieldByName('TotalQty').AsFloat; // Harvest total qty

       if not qryHarvestNames.FieldByName('PackedQty').IsNull then
         PackedQty := qryHarvestNames.FieldByName('PackedQty').AsFloat; // total qty, packed earlier by other "CreatePackage"s

       // take into account available Harvest qty
       FMaxQty := Max(0, (TotalQty - PackedQty));
       sMaxPackgQty := FormatFloat('0.00', FMaxQty);

       // set values in frame
       FHarvestFrame.lbInfo.Caption := Format('Do not exceed the max value %s', [sMaxPackgQty]);
       FHarvestFrame.lbHarvestUnits.Caption := sUOM;
    end;
end;

procedure TfmStSCreatePackage.OnHarvestQtyChange(Sender: TObject);
var
  HarvestQty, PackgQty, UOMMult: Double;
begin
  UOMMult := PackageUOMMultiplier;
  HarvestQty := StrToFloatDef(FHarvestFrame.edtHarvestQty.Text, 0);
  PackgQty := UOMMult * HarvestQty;

  if not IsReadOnly then
    if PackgQty > FMaxQty then PackgQty := 0;

  FHarvestFrame.edtPackgQty.Text := FloatToStrF(PackgQty, ffFixed, 15, 3);
end;

procedure TfmStSCreatePackage.OnHarvestQtyExit(Sender: TObject);
var
  edtQty: TEdit;
begin
  if Sender is TEdit then
  begin
    edtQty := TEdit(Sender);
    if StrToFloatDef(edtQty.Text, 0) > FMaxQty then
    begin
      MessageDlgXP_Vista('The value you entered exceeds the available Harvest quantity', mtWarning, [mbOK], 0);
      if edtQty.CanFocus then edtQty.SetFocus;
    end;
  end;
end;

procedure TfmStSCreatePackage.OnChangeStrain(Sender: TObject);
var
  cbbStrain: TComboBox;
begin
  cbbStrain := nil;
  if Sender is TComboBox then
    cbbStrain := TComboBox(Sender);

  if (cbbStrain <> nil) and qryAvailable.Active then
  begin
    qryAvailable.Filter   := 'StrainName=' + QuotedStr(cbbStrain.Text);
    qryAvailable.Filtered := True;
  end;
end;

procedure TfmStSCreatePackage.Populate_qryPackgTag;
var
  ErrorMsg :String;
begin
  try
    commondblib.ExecuteDBCommand( 'DROP TABLE if EXISTS ' + FAvPkgTagTable +'3; '+
                                  ' CREATE TABLE ' + FAvPkgTagTable +'3 ( '+
                                  '   partsId int(11) DEFAULT  0, '+
                                  '   serialnumber varchar(100) DEFAULT NULL, '+
                                  '   pqaid int(11) DEFAULT NULL, '+
                                  '   supplierid int(11) DEFAULT  0 '+
                                  ' ) ENGINE=MyISAM DEFAULT CHARSET=UTF8;', ErrorMsg);
    with scrptMain do
    begin
      SQL.text := StSTagList(FAvPkgTagTable);
      SQL.Add(ExtraSQL(FAvPkgTagTable));
    end;
    executewithProgress;

    CloseDB(qryPackgTag);
    qryPackgTag.ParamByName('partsId').AsInteger  := stslib.StSPackageTagProductID;
    openDB(qryPackgTag);
  except
    on E: Exception do
      Logtext(Format('TfmStSCreatePackage.Populate_qryPackgTag [%s] %s', [E.Classname, E.Message]),'', True);
  end;
end;

procedure TfmStSCreatePackage.qryAvailableQtyChange(Sender: TField);
var
  fldActiveCount: TField;
begin
  inherited;

  if FMode = modeImmature then begin
     with Sender do begin
       if AsInteger < 0 then AsInteger := 0;

       fldActiveCount := DataSet.FieldByName('ActiveCount');

       if fldActiveCount <> nil then
         if AsInteger > fldActiveCount.AsInteger then begin
           MessageDlgXP_Vista('The Qty cannot exceed the ActiveCount value', mtWarning, [mbOK], 0);
           AsInteger := fldActiveCount.AsInteger;
         end;
     end;
  end;
end;

function TfmStSCreatePackage.StsPackage: TStSPackage;
begin

  if Busobj <> nil then  // if Busobj was passed in the constructor
    Result := Busobj as TStsPackage
  else
    Result := FBusobj;

  if Result = nil then begin
    FBusobj := TStsPackage.Create(Self);
    FBusobj.Load(FPackageID);
    Result := FBusobj;
  end;
end;

procedure TfmStSCreatePackage.UpdateDetailGridView;
var
  grdDetail: TwwDBGrid;
begin
  if FMode = modeHarvest then Exit;

  grdDetail := nil;

  if FImmatureFrame <> nil then
    grdDetail := FImmatureFrame.wdbgrdAvailable;

  if FPackageFrame <> nil then
    grdDetail := FPackageFrame.wdbgrdAvailable;

  Assert(grdDetail <> nil, 'Expected grdDetail <> nil');

  if grdDetail = nil then Exit;

  if IsReadOnly then begin
    grdDetail.UseTFields := False;
    with grdDetail.Selected do begin
      Clear;
      Add('StsTag' + #9 + '20' + #9 + 'StsTag' + #9 + 'T' + #9);     // FieldName #9 Width #9 Title #9 ReadOnly(T/F) #9
      Add('Qty' + #9 + '10' + #9 + 'Qty' + #9 + 'T' + #9);
    end;
    grdDetail.ApplySelected;
  end;

  if not IsReadOnly then begin
    case FMode of
      modeImmature: begin
        grdDetail.UseTFields := False;
        with grdDetail.Selected do begin
          Clear;
          Add('Check'#9'8'#9'Check'#9'F');
          Add('Tag'#9'20'#9'StsTag'#9'T');      // FieldName #9 Width #9 Title #9 ReadOnly(T/F)
          Add('Qty'#9'10'#9'Qty'#9'F');
          Add('ActiveCount'#9'10'#9'ActiveCount'#9'T');
        end;
        grdDetail.ApplySelected;
      end;

      modeVegetative: begin
        grdDetail.UseTFields := False;
        with grdDetail.Selected do begin
          Clear;
          Add('Check'#9'8'#9'Check'#9'F'#9);
          Add('Tag'#9'20'#9'StsTag'#9'T'#9);      // FieldName #9 Width #9 Title #9 ReadOnly(T/F) #9
        end;
        grdDetail.ApplySelected;
      end;
    end;
  end;

end;

procedure TfmStSCreatePackage.UpdateReadOnly;
var
  bReadonly: Boolean;
begin
  bReadonly := IsReadOnly;

  cbbNewPackg.Enabled  := not bReadonly;
  cbbPackgSrc.Enabled  := not bReadonly;
  dtpPackgDate.Enabled := not bReadonly;

  dblkcbbDepartment.ReadOnly := bReadOnly;
  edtPackgName.ReadOnly      := bReadOnly;

  if FImmatureFrame <> nil then
    with FImmatureFrame do begin
      cbbStrain.Enabled        := not bReadonly;
      wdbgrdAvailable.ReadOnly := bReadonly;
      if bReadOnly then
        pnlLTop.Caption := '';
    end;

  if FPackageFrame <> nil then
    with FPackageFrame do begin
      wdbgrdAvailable.ReadOnly := bReadonly;
      if bReadOnly then
        pnlLTop.Caption := '';
    end;

  if FHarvestFrame <> nil then
    with FHarvestFrame do begin
      cbbHarvestName.Enabled := not bReadonly;
      cbbPackgUnits.ReadOnly := bReadOnly;
      edtHarvestQty.ReadOnly := bReadOnly;
    end;
end;

procedure TfmStSCreatePackage.UpdateView;
begin
  cbbPackgSrc.Items.Clear;

  // assign items in "Package source" combobox
  case FMode of
    modeImmature: begin
      if IsReadOnly then
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgImmature])
      else begin
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgImmature]);
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgVegetative]);
      end;
    end;

    modeVegetative: begin
      if IsReadOnly then
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgVegetative])
      else begin
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgVegetative]);
        cbbPackgSrc.Items.Add(PackageTypeNames[pkgImmature]);
      end;
    end;

    modeHarvest:
      cbbPackgSrc.Items.Add(PackageTypeNames[pkgHarvest]);

    modeAnotherPackage:
      cbbPackgSrc.Items.Add(PackageTypeNames[pkgPackage]);
  end;

  // if show existing package then use StsPackage values
  if IsReadOnly and (StsPackage <> nil) then
  begin
    dtpPackgDate.Date := StsPackage.PackageDate;
    edtPackgName.Text := StsPackage.PackageName;
    edtStsTag.Text    := StsPackage.StSTagObj.StsTag;

    // show the "StsTag" edit and hide the "New package tag" combobox
    edtStsTag.Width     := cbbNewPackg.Width;
    edtStsTag.Visible   := True;
    cbbNewPackg.Visible := False;

    lblPackgTag.Caption := 'Package Tag';
    Title               := Format('Package #%d', [StsPackage.ID]);
  end;

  // if show new package then set default values
  if not IsReadOnly then dtpPackgDate.Date := Now;

  if cbbPackgSrc.Items.Count > 0 then
  begin
    cbbPackgSrc.ItemIndex := 0;
    cbbPackgSrcChange(cbbPackgSrc);
  end;
end;

procedure TfmStSCreatePackage.AddSQL_qryPackgTag;
begin
  try
    FAvPkgTagTable := CommonDbLib.GetUserTemporaryTableName('StsTags');
    Logtext('FAvPkgTagTable= ' + FAvPkgTagTable, '', True);
    closedb(qryPackgTag);
    with qryPackgTag.SQL do
    begin
      Clear;
      Add('Select');
      Add('T.Serialnumber ');
      Add('from '+ FAvPkgTagTable + ' T ');
      Add('where (T.UsedOn IS NULL) and (PartsId =:partsId) ');
      Add('Order by T.Serialnumber');
    end;
  except
    on E: Exception do
      Logtext(Format('TfmStSCreatePackage.AddSQL_qryPackgTag [%s] %s', [E.Classname, E.Message]), '', True);
  end;
end;



end.
